// Copyright 2023, Pulumi Corporation.  All rights reserved.

// Code generated by gen_apply/main; DO NOT EDIT.

package infer

import "errors"


func Apply[T1, U any](o1 Output[T1], f func(T1) U) Output[U] {
	return ApplyErr(o1, func(v1 T1) (U, error) {
		return f(v1), nil
	})
}

func ApplyErr[T1, U any](o1 Output[T1], f func(T1) (U, error)) Output[U] {
	o1.ensure()
	result := newOutput[U](nil, o1.secret, o1.resolvable)
	go applyResult(o1, result, f)
	return result
}

func applyResult[T1, U any](o1 Output[T1], to Output[U], f func(T1) (U, error)) {
	if !o1.resolvable {
		return
	}
	o1.wait()

	// Propagate the change
	to.join.L.Lock()
	defer to.join.L.Unlock()

	if err := errors.Join(o1.err); err == nil {
		tmp, err := f(*o1.value)
		if err == nil {
			to.value = &tmp
		} else {
			to.err = err
		}
	} else {
		to.err = err
	}
	to.resolved = true
	to.join.Broadcast()
}

func Apply2[T1, T2, U any](o1 Output[T1], o2 Output[T2], f func(T1, T2) U) Output[U] {
	return Apply2Err(o1, o2, func(v1 T1, v2 T2) (U, error) {
		return f(v1, v2), nil
	})
}

func Apply2Err[T1, T2, U any](o1 Output[T1], o2 Output[T2], f func(T1, T2) (U, error)) Output[U] {
	o1.ensure()
	o2.ensure()
	result := newOutput[U](nil, o1.secret || o2.secret, o1.resolvable && o2.resolvable)
	go apply2Result(o1, o2, result, f)
	return result
}

func apply2Result[T1, T2, U any](o1 Output[T1], o2 Output[T2], to Output[U], f func(T1, T2) (U, error)) {
	if !o1.resolvable || !o2.resolvable {
		return
	}
	o1.wait()
	o2.wait()

	// Propagate the change
	to.join.L.Lock()
	defer to.join.L.Unlock()

	if err := errors.Join(o1.err, o2.err); err == nil {
		tmp, err := f(*o1.value, *o2.value)
		if err == nil {
			to.value = &tmp
		} else {
			to.err = err
		}
	} else {
		to.err = err
	}
	to.resolved = true
	to.join.Broadcast()
}

func Apply3[T1, T2, T3, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], f func(T1, T2, T3) U) Output[U] {
	return Apply3Err(o1, o2, o3, func(v1 T1, v2 T2, v3 T3) (U, error) {
		return f(v1, v2, v3), nil
	})
}

func Apply3Err[T1, T2, T3, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], f func(T1, T2, T3) (U, error)) Output[U] {
	o1.ensure()
	o2.ensure()
	o3.ensure()
	result := newOutput[U](nil, o1.secret || o2.secret || o3.secret, o1.resolvable && o2.resolvable && o3.resolvable)
	go apply3Result(o1, o2, o3, result, f)
	return result
}

func apply3Result[T1, T2, T3, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], to Output[U], f func(T1, T2, T3) (U, error)) {
	if !o1.resolvable || !o2.resolvable || !o3.resolvable {
		return
	}
	o1.wait()
	o2.wait()
	o3.wait()

	// Propagate the change
	to.join.L.Lock()
	defer to.join.L.Unlock()

	if err := errors.Join(o1.err, o2.err, o3.err); err == nil {
		tmp, err := f(*o1.value, *o2.value, *o3.value)
		if err == nil {
			to.value = &tmp
		} else {
			to.err = err
		}
	} else {
		to.err = err
	}
	to.resolved = true
	to.join.Broadcast()
}

func Apply4[T1, T2, T3, T4, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], o4 Output[T4], f func(T1, T2, T3, T4) U) Output[U] {
	return Apply4Err(o1, o2, o3, o4, func(v1 T1, v2 T2, v3 T3, v4 T4) (U, error) {
		return f(v1, v2, v3, v4), nil
	})
}

func Apply4Err[T1, T2, T3, T4, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], o4 Output[T4], f func(T1, T2, T3, T4) (U, error)) Output[U] {
	o1.ensure()
	o2.ensure()
	o3.ensure()
	o4.ensure()
	result := newOutput[U](nil, o1.secret || o2.secret || o3.secret || o4.secret, o1.resolvable && o2.resolvable && o3.resolvable && o4.resolvable)
	go apply4Result(o1, o2, o3, o4, result, f)
	return result
}

func apply4Result[T1, T2, T3, T4, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], o4 Output[T4], to Output[U], f func(T1, T2, T3, T4) (U, error)) {
	if !o1.resolvable || !o2.resolvable || !o3.resolvable || !o4.resolvable {
		return
	}
	o1.wait()
	o2.wait()
	o3.wait()
	o4.wait()

	// Propagate the change
	to.join.L.Lock()
	defer to.join.L.Unlock()

	if err := errors.Join(o1.err, o2.err, o3.err, o4.err); err == nil {
		tmp, err := f(*o1.value, *o2.value, *o3.value, *o4.value)
		if err == nil {
			to.value = &tmp
		} else {
			to.err = err
		}
	} else {
		to.err = err
	}
	to.resolved = true
	to.join.Broadcast()
}

func Apply5[T1, T2, T3, T4, T5, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], o4 Output[T4], o5 Output[T5], f func(T1, T2, T3, T4, T5) U) Output[U] {
	return Apply5Err(o1, o2, o3, o4, o5, func(v1 T1, v2 T2, v3 T3, v4 T4, v5 T5) (U, error) {
		return f(v1, v2, v3, v4, v5), nil
	})
}

func Apply5Err[T1, T2, T3, T4, T5, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], o4 Output[T4], o5 Output[T5], f func(T1, T2, T3, T4, T5) (U, error)) Output[U] {
	o1.ensure()
	o2.ensure()
	o3.ensure()
	o4.ensure()
	o5.ensure()
	result := newOutput[U](nil, o1.secret || o2.secret || o3.secret || o4.secret || o5.secret, o1.resolvable && o2.resolvable && o3.resolvable && o4.resolvable && o5.resolvable)
	go apply5Result(o1, o2, o3, o4, o5, result, f)
	return result
}

func apply5Result[T1, T2, T3, T4, T5, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], o4 Output[T4], o5 Output[T5], to Output[U], f func(T1, T2, T3, T4, T5) (U, error)) {
	if !o1.resolvable || !o2.resolvable || !o3.resolvable || !o4.resolvable || !o5.resolvable {
		return
	}
	o1.wait()
	o2.wait()
	o3.wait()
	o4.wait()
	o5.wait()

	// Propagate the change
	to.join.L.Lock()
	defer to.join.L.Unlock()

	if err := errors.Join(o1.err, o2.err, o3.err, o4.err, o5.err); err == nil {
		tmp, err := f(*o1.value, *o2.value, *o3.value, *o4.value, *o5.value)
		if err == nil {
			to.value = &tmp
		} else {
			to.err = err
		}
	} else {
		to.err = err
	}
	to.resolved = true
	to.join.Broadcast()
}

func Apply6[T1, T2, T3, T4, T5, T6, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], o4 Output[T4], o5 Output[T5], o6 Output[T6], f func(T1, T2, T3, T4, T5, T6) U) Output[U] {
	return Apply6Err(o1, o2, o3, o4, o5, o6, func(v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6) (U, error) {
		return f(v1, v2, v3, v4, v5, v6), nil
	})
}

func Apply6Err[T1, T2, T3, T4, T5, T6, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], o4 Output[T4], o5 Output[T5], o6 Output[T6], f func(T1, T2, T3, T4, T5, T6) (U, error)) Output[U] {
	o1.ensure()
	o2.ensure()
	o3.ensure()
	o4.ensure()
	o5.ensure()
	o6.ensure()
	result := newOutput[U](nil, o1.secret || o2.secret || o3.secret || o4.secret || o5.secret || o6.secret, o1.resolvable && o2.resolvable && o3.resolvable && o4.resolvable && o5.resolvable && o6.resolvable)
	go apply6Result(o1, o2, o3, o4, o5, o6, result, f)
	return result
}

func apply6Result[T1, T2, T3, T4, T5, T6, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], o4 Output[T4], o5 Output[T5], o6 Output[T6], to Output[U], f func(T1, T2, T3, T4, T5, T6) (U, error)) {
	if !o1.resolvable || !o2.resolvable || !o3.resolvable || !o4.resolvable || !o5.resolvable || !o6.resolvable {
		return
	}
	o1.wait()
	o2.wait()
	o3.wait()
	o4.wait()
	o5.wait()
	o6.wait()

	// Propagate the change
	to.join.L.Lock()
	defer to.join.L.Unlock()

	if err := errors.Join(o1.err, o2.err, o3.err, o4.err, o5.err, o6.err); err == nil {
		tmp, err := f(*o1.value, *o2.value, *o3.value, *o4.value, *o5.value, *o6.value)
		if err == nil {
			to.value = &tmp
		} else {
			to.err = err
		}
	} else {
		to.err = err
	}
	to.resolved = true
	to.join.Broadcast()
}

func Apply7[T1, T2, T3, T4, T5, T6, T7, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], o4 Output[T4], o5 Output[T5], o6 Output[T6], o7 Output[T7], f func(T1, T2, T3, T4, T5, T6, T7) U) Output[U] {
	return Apply7Err(o1, o2, o3, o4, o5, o6, o7, func(v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7) (U, error) {
		return f(v1, v2, v3, v4, v5, v6, v7), nil
	})
}

func Apply7Err[T1, T2, T3, T4, T5, T6, T7, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], o4 Output[T4], o5 Output[T5], o6 Output[T6], o7 Output[T7], f func(T1, T2, T3, T4, T5, T6, T7) (U, error)) Output[U] {
	o1.ensure()
	o2.ensure()
	o3.ensure()
	o4.ensure()
	o5.ensure()
	o6.ensure()
	o7.ensure()
	result := newOutput[U](nil, o1.secret || o2.secret || o3.secret || o4.secret || o5.secret || o6.secret || o7.secret, o1.resolvable && o2.resolvable && o3.resolvable && o4.resolvable && o5.resolvable && o6.resolvable && o7.resolvable)
	go apply7Result(o1, o2, o3, o4, o5, o6, o7, result, f)
	return result
}

func apply7Result[T1, T2, T3, T4, T5, T6, T7, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], o4 Output[T4], o5 Output[T5], o6 Output[T6], o7 Output[T7], to Output[U], f func(T1, T2, T3, T4, T5, T6, T7) (U, error)) {
	if !o1.resolvable || !o2.resolvable || !o3.resolvable || !o4.resolvable || !o5.resolvable || !o6.resolvable || !o7.resolvable {
		return
	}
	o1.wait()
	o2.wait()
	o3.wait()
	o4.wait()
	o5.wait()
	o6.wait()
	o7.wait()

	// Propagate the change
	to.join.L.Lock()
	defer to.join.L.Unlock()

	if err := errors.Join(o1.err, o2.err, o3.err, o4.err, o5.err, o6.err, o7.err); err == nil {
		tmp, err := f(*o1.value, *o2.value, *o3.value, *o4.value, *o5.value, *o6.value, *o7.value)
		if err == nil {
			to.value = &tmp
		} else {
			to.err = err
		}
	} else {
		to.err = err
	}
	to.resolved = true
	to.join.Broadcast()
}

func Apply8[T1, T2, T3, T4, T5, T6, T7, T8, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], o4 Output[T4], o5 Output[T5], o6 Output[T6], o7 Output[T7], o8 Output[T8], f func(T1, T2, T3, T4, T5, T6, T7, T8) U) Output[U] {
	return Apply8Err(o1, o2, o3, o4, o5, o6, o7, o8, func(v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8) (U, error) {
		return f(v1, v2, v3, v4, v5, v6, v7, v8), nil
	})
}

func Apply8Err[T1, T2, T3, T4, T5, T6, T7, T8, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], o4 Output[T4], o5 Output[T5], o6 Output[T6], o7 Output[T7], o8 Output[T8], f func(T1, T2, T3, T4, T5, T6, T7, T8) (U, error)) Output[U] {
	o1.ensure()
	o2.ensure()
	o3.ensure()
	o4.ensure()
	o5.ensure()
	o6.ensure()
	o7.ensure()
	o8.ensure()
	result := newOutput[U](nil, o1.secret || o2.secret || o3.secret || o4.secret || o5.secret || o6.secret || o7.secret || o8.secret, o1.resolvable && o2.resolvable && o3.resolvable && o4.resolvable && o5.resolvable && o6.resolvable && o7.resolvable && o8.resolvable)
	go apply8Result(o1, o2, o3, o4, o5, o6, o7, o8, result, f)
	return result
}

func apply8Result[T1, T2, T3, T4, T5, T6, T7, T8, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], o4 Output[T4], o5 Output[T5], o6 Output[T6], o7 Output[T7], o8 Output[T8], to Output[U], f func(T1, T2, T3, T4, T5, T6, T7, T8) (U, error)) {
	if !o1.resolvable || !o2.resolvable || !o3.resolvable || !o4.resolvable || !o5.resolvable || !o6.resolvable || !o7.resolvable || !o8.resolvable {
		return
	}
	o1.wait()
	o2.wait()
	o3.wait()
	o4.wait()
	o5.wait()
	o6.wait()
	o7.wait()
	o8.wait()

	// Propagate the change
	to.join.L.Lock()
	defer to.join.L.Unlock()

	if err := errors.Join(o1.err, o2.err, o3.err, o4.err, o5.err, o6.err, o7.err, o8.err); err == nil {
		tmp, err := f(*o1.value, *o2.value, *o3.value, *o4.value, *o5.value, *o6.value, *o7.value, *o8.value)
		if err == nil {
			to.value = &tmp
		} else {
			to.err = err
		}
	} else {
		to.err = err
	}
	to.resolved = true
	to.join.Broadcast()
}

func Apply9[T1, T2, T3, T4, T5, T6, T7, T8, T9, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], o4 Output[T4], o5 Output[T5], o6 Output[T6], o7 Output[T7], o8 Output[T8], o9 Output[T9], f func(T1, T2, T3, T4, T5, T6, T7, T8, T9) U) Output[U] {
	return Apply9Err(o1, o2, o3, o4, o5, o6, o7, o8, o9, func(v1 T1, v2 T2, v3 T3, v4 T4, v5 T5, v6 T6, v7 T7, v8 T8, v9 T9) (U, error) {
		return f(v1, v2, v3, v4, v5, v6, v7, v8, v9), nil
	})
}

func Apply9Err[T1, T2, T3, T4, T5, T6, T7, T8, T9, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], o4 Output[T4], o5 Output[T5], o6 Output[T6], o7 Output[T7], o8 Output[T8], o9 Output[T9], f func(T1, T2, T3, T4, T5, T6, T7, T8, T9) (U, error)) Output[U] {
	o1.ensure()
	o2.ensure()
	o3.ensure()
	o4.ensure()
	o5.ensure()
	o6.ensure()
	o7.ensure()
	o8.ensure()
	o9.ensure()
	result := newOutput[U](nil, o1.secret || o2.secret || o3.secret || o4.secret || o5.secret || o6.secret || o7.secret || o8.secret || o9.secret, o1.resolvable && o2.resolvable && o3.resolvable && o4.resolvable && o5.resolvable && o6.resolvable && o7.resolvable && o8.resolvable && o9.resolvable)
	go apply9Result(o1, o2, o3, o4, o5, o6, o7, o8, o9, result, f)
	return result
}

func apply9Result[T1, T2, T3, T4, T5, T6, T7, T8, T9, U any](o1 Output[T1], o2 Output[T2], o3 Output[T3], o4 Output[T4], o5 Output[T5], o6 Output[T6], o7 Output[T7], o8 Output[T8], o9 Output[T9], to Output[U], f func(T1, T2, T3, T4, T5, T6, T7, T8, T9) (U, error)) {
	if !o1.resolvable || !o2.resolvable || !o3.resolvable || !o4.resolvable || !o5.resolvable || !o6.resolvable || !o7.resolvable || !o8.resolvable || !o9.resolvable {
		return
	}
	o1.wait()
	o2.wait()
	o3.wait()
	o4.wait()
	o5.wait()
	o6.wait()
	o7.wait()
	o8.wait()
	o9.wait()

	// Propagate the change
	to.join.L.Lock()
	defer to.join.L.Unlock()

	if err := errors.Join(o1.err, o2.err, o3.err, o4.err, o5.err, o6.err, o7.err, o8.err, o9.err); err == nil {
		tmp, err := f(*o1.value, *o2.value, *o3.value, *o4.value, *o5.value, *o6.value, *o7.value, *o8.value, *o9.value)
		if err == nil {
			to.value = &tmp
		} else {
			to.err = err
		}
	} else {
		to.err = err
	}
	to.resolved = true
	to.join.Broadcast()
}
