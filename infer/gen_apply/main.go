package main

import (
	"bytes"
	"fmt"
	"os"
	"strings"
	"text/template"
)

func must[T any](t T, err error) T {
	if err != nil {
		panic(err)
	}
	return t
}

var applyFuncs = must(template.New("apply").Parse(
	`
func Apply{{.inputs}}[{{.inputTypes}}U any]({{.inputArgsWithTypes}}f func({{.inputTypesNoComma}}) U) Output[U] {
	return Apply{{.inputs}}Err({{.inputArgsNoTypes}}func({{.inputArgsRawTypes}}) (U, error) {
		return f({{.inputArgsRaw}}), nil
	})
}

func Apply{{.inputs}}Err[{{.inputTypes}}U any]({{.inputArgsWithTypes}}f func({{.inputTypesNoComma}}) (U, error)) Output[U] {
	var deps deps
	result := newOutput[U](nil, {{.orSecrets}}, deps{{.joinDeps}})
	go apply{{.inputs}}Result({{.inputArgsNoTypes}}result, f)
	return result
}

func apply{{.inputs}}Result[{{.inputTypes}}U any]({{.inputArgsWithTypes}}to Output[U], f func({{.inputTypesNoComma}}) (U, error)) {
	if {{.orCanResolve}} {
		return
	}
	{{.wait}}

	// Propagate the change
	to.join.L.Lock()
	defer to.join.L.Unlock()

	if err := errors.Join({{.errs}}); err == nil {
		tmp, err := f({{.values}})
		if err == nil {
			to.value = &tmp
		} else {
			to.err = err
		}
	} else {
		to.err = err
	}
	to.resolved = true
	to.join.Broadcast()
}
`))

func main() {
	b := new(bytes.Buffer)
	b.WriteString(`// Code generated by gen_apply/main; DO NOT EDIT.

package infer

import "errors"

`)
	for i := 0; i < 9; i++ {
		var inputs string
		if i > 0 {
			inputs = fmt.Sprintf("%d", i+1)
		}
		err := applyFuncs.Execute(b, map[string]string{
			"inputs":            inputs,                  // A number, like "3"
			"inputTypes":        formatN(i, "T%d, ", ""), // "T1, T2, T3, "
			"inputTypesNoComma": formatN(i, "T%d", ", "), // "T1, T2, T3"
			// "o1 Output[T1], o2 Output[T2], o3 Output[T3], "
			"inputArgsWithTypes": formatN(i, "o%[1]d Output[T%[1]d], ", ""),
			"inputArgsNoTypes":   formatN(i, "o%d, ", ""),           // "o1, o2, "
			"inputArgsRawTypes":  formatN(i, "v%[1]d T%[1]d", ", "), // "v1 T1, v2 T2"
			"inputArgsRaw":       formatN(i, "v%d", ", "),           // "v1, v2"
			"orSecrets":          formatN(i, "o%d.secret", " || "),  // "o1.secret || o2.secret"
			// "!o1.deps.canResolve() || !o1.deps.canResolve()"
			"orCanResolve": formatN(i, "!o%d.deps.canResolve()", " || "),
			"wait":         formatN(i, "o%d.wait()", "\n\t"),  // "o1.wait()\n\to2.wait()"
			"errs":         formatN(i, "o%d.err", ", "),       // "o1.err, o2.err"
			"values":       formatN(i, "*o%d.value", ", "),    // "*o1.value, *o2.value"
			"joinDeps":     formatN(i, ".join(o%d.deps)", ""), // ".join(o1.deps).join(o2.deps)"
		})
		if err != nil {
			panic(err)
		}
	}

	fmt.Printf("Writing to %s\n", os.Args[2])
	err := os.WriteFile(os.Args[2], b.Bytes(), 0600)
	if err != nil {
		panic(err)
	}
}

func formatN(to int, msg, join string) string {
	var arr []string
	for i := 1; i <= to+1; i++ {
		arr = append(arr, fmt.Sprintf(msg, i))
	}
	return strings.Join(arr, join)
}
