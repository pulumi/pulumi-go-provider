// Copyright 2024, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package grpc

import (
	"context"
	"testing"

	"github.com/pulumi/pulumi/sdk/v3/go/common/util/rpcutil/rpcerror"
	pulumirpc "github.com/pulumi/pulumi/sdk/v3/proto/go"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"google.golang.org/protobuf/types/known/structpb"

	p "github.com/pulumi/pulumi-go-provider"
	"github.com/pulumi/pulumi-go-provider/tests/grpc/partial"
)

// partial_test.go asserts on the errors returned by the gRPC server generated by
// [p.Provider] and [infer.Provider]. It can't use replay, since that doesn't expose
// errors with enough fidelity to assert against.

// must makes f infallible by requiring that it does not return an error.
func must[I, T any](t *testing.T, f func(I) (T, error), i I) T {
	v, err := f(i)
	require.NoError(t, err)
	return v
}

func TestPartialCreate(t *testing.T) {
	t.Parallel()
	s, err := p.RawServer("partial", "1.0.0", partial.Provider())(nil)
	require.NoError(t, err)

	_, err = s.Create(context.Background(), &pulumirpc.CreateRequest{
		Urn: "urn:pulumi:dev::dev::partial:index:Partial::t1",
		Properties: must(t, structpb.NewStruct, map[string]any{
			"s": "for-create",
		}),
	})

	rpcError, ok := rpcerror.FromError(err)
	if assert.True(t, ok) {
		for _, d := range rpcError.Details() {
			initFailed, ok := d.(*pulumirpc.ErrorResourceInitFailed)
			if !ok {
				continue
			}
			assert.Equal(t, (&pulumirpc.ErrorResourceInitFailed{
				Id: "id",
				Properties: must(t, structpb.NewStruct, map[string]any{
					"s":   "+for-create",
					"out": "partial-create",
				}),
				Reasons: []string{"create: failed to fully init"},
			}).String(), initFailed.String())
		}
	}
}

func TestPartialUpdate(t *testing.T) {
	t.Parallel()
	s, err := p.RawServer("partial", "1.0.0", partial.Provider())(nil)
	require.NoError(t, err)

	_, err = s.Update(context.Background(), &pulumirpc.UpdateRequest{
		Id:  "update-id",
		Urn: "urn:pulumi:dev::dev::partial:index:Partial::t1",
		News: must(t, structpb.NewStruct, map[string]any{
			"s": "for-update",
		}),
		Olds: must(t, structpb.NewStruct, map[string]any{
			"s":   "+for-create",
			"out": "partial-init",
		}),
	})

	rpcError, ok := rpcerror.FromError(err)
	if assert.True(t, ok) {
		for _, d := range rpcError.Details() {
			initFailed, ok := d.(*pulumirpc.ErrorResourceInitFailed)
			if !ok {
				continue
			}
			assert.Equal(t, (&pulumirpc.ErrorResourceInitFailed{
				Id: "update-id",
				Properties: must(t, structpb.NewStruct, map[string]any{
					"s":   "from-update",
					"out": "partial-update",
				}),
				Reasons: []string{"update: failed to continue init"},
			}).String(), initFailed.String())
		}
	}
}
func TestPartialRead(t *testing.T) {
	t.Parallel()
	s, err := p.RawServer("partial", "1.0.0", partial.Provider())(nil)
	require.NoError(t, err)

	_, err = s.Read(context.Background(), &pulumirpc.ReadRequest{
		Id:  "read-id",
		Urn: "urn:pulumi:dev::dev::partial:index:Partial::t1",
		Inputs: must(t, structpb.NewStruct, map[string]any{
			"s": "for-read",
		}),
		Properties: must(t, structpb.NewStruct, map[string]any{
			"s":   "from-update",
			"out": "state-for-read",
		}),
	})

	rpcError, ok := rpcerror.FromError(err)
	if assert.True(t, ok) {
		for _, d := range rpcError.Details() {
			initFailed, ok := d.(*pulumirpc.ErrorResourceInitFailed)
			if !ok {
				continue
			}
			assert.Equal(t, (&pulumirpc.ErrorResourceInitFailed{
				Id: "from-read-id",
				Inputs: must(t, structpb.NewStruct, map[string]any{
					"s": "from-read-input",
				}),
				Properties: must(t, structpb.NewStruct, map[string]any{
					"s":   "s-state-from-read",
					"out": "out-state-from-read",
				}),
				Reasons: []string{"read: failed to finish read"},
			}).String(), initFailed.String())
		}
	}
}
